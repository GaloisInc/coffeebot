{"version":3,"sources":["webpack://coffeebot/webpack/bootstrap","webpack://coffeebot/./src/coffeebot.js"],"names":[],"mappings":";;QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;AClFA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,MAAM;AACnB;AACA;AACA;AACA;;AAEA;AACA,sCAAsC,KAAK;;AAE3C;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,WAAW,YAAY;AACvB,WAAW,OAAO;AAClB,aAAa,MAAM;AACnB;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,WAAW;AACxB;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,WAAW,SAAS;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,yBAAyB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa,YAAY;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA,WAAW,IAAI;AACf,aAAa,IAAI;AACjB;AACA;AACA;;AAEA,iCAAiC,OAAO;AACxC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,WAAW,IAAI;AACf,aAAa,IAAI;AACjB;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,8BAA8B;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,YAAY;AACvB,WAAW,yBAAyB;AACpC,aAAa,WAAW;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,mDAAmD,wBAAwB;AAC3E;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;;AAEA,YAAY,oBAAoB,GAAG,qBAAqB,GAAG,gBAAgB;AAC3E;;AAEA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA;AACA,MAAM,SAAS;;AAEf;;AAEA,qBAAqB;;AAErB,+EAA+E;;AAE/E,qFAAqF;;AAErF;AACA,EAAE;;AAEF;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,WAAW;AACtB;AACA;AACA;;AAEA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA,aAAa,WAAW;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG,M;AACH;;AAEA;AACA;AACA,WAAW,yBAAyB;AACpC,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,GAAG,mDAAmD;;AAEzD;AACA;AACA;AACA;AACA,sCAAsC,SAAS;AAC/C;;AAEA;;AAEA,kDAAkD,oBAAoB;AACtE;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"main.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/coffeebot.js\");\n","const PAIRING_SHEET_NAME = 'Signup';\nconst NEXT_PAIRINGS_SHEET_NAME = 'Next Pairings';\nconst RECORD_SHEET_NAME = 'Past Pairings';\nconst RECORD_SHEET_HEADINGS = ['Pairing Date', 'Paired Emails']\nconst MAX_PAIRING_TRIES = 3;\nconst EMAIL_SEPARATOR = ',';\n\nconst PAIRING_COLUMNS_MAP = {\n  NAME: 0,\n  EMAIL: 1,\n  TIMEZONE: 2,\n  SNOOZE: 3,\n  CADENCE: 4,\n  TOPICS: 5,\n};\n\n/**\n * @description Log error message\n * @param {string} error message to log\n */\nfunction logError(error) {\n  Logger.log('ERROR: %s', error);\n}\n\n/**\n * @description Get the week of the year (1 offset)\n * @returns {number} 1-53\n * @see https://www.epochconverter.com/weeknumbers\n */\nfunction getWeekOfYear() {\n  const target  = new Date();\n  const dayNr   = (target.getDay() + 6) % 7;\n\n  target.setDate(target.getDate() - dayNr + 3);\n\n  const firstThursday = target.valueOf();\n\n  target.setMonth(0, 1);\n\n  if (target.getDay() != 4) {\n      target.setMonth(0, 1 + ((4 - target.getDay()) + 7) % 7);\n  }\n\n  return 1 + Math.ceil((firstThursday - target) / 604800000);\n}\n\n/**\n * @description Accessor to get a specific Sheet from our Spreadsheet\n *              if it is unable to find the requested Sheet, it will\n *              create one for us\n * @param {string} name label for sheet needed\n * @returns {Sheet} Sheet requested or newly created Sheet with given name\n */\nfunction getSpreadsheet(name, headings=[]) {\n  const spreadsheet = SpreadsheetApp.getActiveSpreadsheet();\n  const sheet = spreadsheet.getSheetByName(name);\n\n  if (!sheet) {\n    logError(`Unable to find sheet \"${name}\", creating one`);\n\n    const newSheet = createSheet(spreadsheet, name);\n\n    if (headings.length > 0) {\n      newSheet.appendRow(headings);\n    }\n\n    return newSheet;\n  }\n\n  return sheet;\n}\n\n/**\n * @description Create a new Sheet with given label\n * @param {Spreadsheet} spreadsheet Spreadsheet we are adding a Sheet to\n * @param {string} name label to assign to created Sheet\n * @returns {Sheet} newly created Sheet\n */\nfunction createSheet(spreadsheet, name) {\n  const sheet = spreadsheet.insertSheet();\n\n  sheet.setName(name);\n\n  return sheet;\n}\n\n/**\n * @description Fetch data from a given Sheet across a given range\n * @param {Sheet} sheet Sheet containing data we need\n * @param {number} startRow index of starting row for data\n * @param {number} endRow index of ending row\n * @param {number} startColumn index of starting column\n * @param {number} endColumn index of ending column\n * @returns {string[][]} list of tuples of spreadsheet data\n */\nfunction getSheetValues(sheet, startRow, endRow, startColumn, endColumn) {\n  const numRows = (endRow - startRow) + 1;\n\n  if (numRows === 0) return [];\n\n  const dataRange = sheet.getRange(startRow, startColumn, numRows, endColumn);\n\n  return dataRange.getValues();\n}\n\n/**\n * @description Utility to serialize given emails for storage\n * @param {string[]} emails \n * @returns {string} lexically ordered emails joined by configured separator\n */\nfunction serializeEmails(emails) {\n  return emails.sort().join(EMAIL_SEPARATOR);\n}\n\n/**\n * @description Utility to deserialize emails from storage\n * @param {string} emails lexically ordered emails joined by configured separator\n * @returns {string[]} list of emails in lexicographical order\n */\nfunction deserializeEmails(emails) {\n  return emails.split(EMAIL_SEPARATOR).filter(e => e.length > 0).sort();\n}\n\n/**\n * @description Generate date for midnight (UTC-0) for today\n * @returns {Date}\n */\nfunction getToday() {\n  return new Date(generatePairingDate());\n}\n\n/**\n * @description Determine if we should omit this participant from today's pairing\n * @param {Date} today - midnight today (UTC-0)\n * @param {string} snooze - datestring \"YYYY/MM/DD\" or empty string\n * @param {boolean}\n */\nfunction shouldSnooze(today, snooze) {\n  if (snooze) {\n    const snoozeDate = new Date(snooze);\n\n    return today.getFullYear() <= snoozeDate.getFullYear() &&\n            today.getMonth() <= snoozeDate.getMonth() &&\n            today.getDate() <= snoozeDate.getDate();\n  }\n\n  return false;\n}\n\n/**\n * @description Gets the \"Signup\" column headings in correct order\n */\nfunction getSignupSheetColumns() {\n  return Object.keys(PAIRING_COLUMNS_MAP).sort((a, b) => PAIRING_COLUMNS_MAP[a] - PAIRING_COLUMNS_MAP[b]);\n}\n\n/**\n * @description Generates a list of participants, randomly shuffled to use for pairing\n * @returns {Object<string, string>[]} randomized list of key/value dictionaries (@see mapRowDataToPairData) representing participants to pair\n */\nfunction getPairingData() {\n  const sheet = getSpreadsheet(PAIRING_SHEET_NAME, getSignupSheetColumns());\n  const startRow = 2;\n  const lastRow = sheet.getLastRow();\n  const participants = getSheetValues(sheet, startRow, lastRow, 1, Object.keys(PAIRING_COLUMNS_MAP).length).map(mapRowDataToPairData);\n  const weekOfYear = getWeekOfYear();\n  const today = getToday();\n  const cadencedParticipants = participants.filter(p => weekOfYear % p.cadence === 0).filter(p => !shouldSnooze(today, p.snooze));\n\n  return shuffle(cadencedParticipants);\n}\n\n/**\n * @description Pulls previous pairing information to help minimize repeat pairings\n * @returns {Set<string>} a Set of lexically ordered, comma-separated email addresses of previous pairings\n */\nfunction getPreviousPairingEmails() {\n  const sheet = getSpreadsheet(RECORD_SHEET_NAME, RECORD_SHEET_HEADINGS);\n  const startRow = 2;\n  const lastRow = sheet.getLastRow();\n\n  return getSheetValues(sheet, startRow, lastRow, 1, 2).reduce((acc, row) => {\n    acc.add(row[1]);\n    return acc;\n  }, new Set());\n}\n\n/**\n * @description Randomly shuffle given list\n * @param {T[]} arr list of items to shuffle\n * @returns {T[]} input list in randomized ordering\n */\nfunction shuffle(arr) {\n  const shuffled = arr.slice();\n\n  for (let i = shuffled.length-1; i > 0; i--) {\n    const j = Math.floor(Math.random() * i)\n    const temp = shuffled[i]\n    shuffled[i] = shuffled[j]\n    shuffled[j] = temp\n  }\n\n  return shuffled;\n}\n\n/**\n * @description Deduplicates list members\n * @param {T[]} list list of items that should be unique\n * @returns {T[]} deduplicated list of T\n */\nfunction uniqify(list) {\n  const seen = new Set();\n  \n  return list.reduce((acc, el) => {\n    if (seen.has(el)) {\n      return acc;\n    } else {\n      seen.add(el);\n      return acc.concat(el);\n    }\n  }, []);\n}\n\n/**\n * @description Converts tuple representation of participants to key/value dictionary\n * @param {string[]} row tuple representing user to match\n * @param {string} row.0 name\n * @param {string} row.1 email\n * @param {string} row.2 timezone\n * @param {string} row.3 topics\n * @returns {Object<string, string|number>} key/value representation of tuple\n */\nfunction mapRowDataToPairData(row) {\n  return {\n    cadence: row[PAIRING_COLUMNS_MAP.CADENCE] || 1,\n    email: row[PAIRING_COLUMNS_MAP.EMAIL],\n    name: row[PAIRING_COLUMNS_MAP.NAME],\n    snooze: row[PAIRING_COLUMNS_MAP.SNOOZE] || '',\n    timezone: row[PAIRING_COLUMNS_MAP.TIMEZONE] || 'UNKNOWN',\n    topics: row[PAIRING_COLUMNS_MAP.TOPICS] || '',\n  };\n}\n\n/**\n * @description Strives to create a unique, random pairing of 2-3 people\n * @param {Set<string>} prevPairings tuple of emails of previously paired people (@see getPreviousPairingEmails)\n * @param {Object<string, string>[]} participants list of key/value dictionaries of people to pair (@see mapRowDataToPairData)\n * @returns {string[][]} list of tuples of email addresses to use in pairing\n */\nfunction randomUniquePairing(prevPairings, participants) {\n  if (participants.length === 0) return [];\n  if (participants.length <= 3)  return [participants.map(p => p.email)];\n\n  const findPotentialPair = (poolOfPossiblePairs, userToPair) => {\n    const pairCandidateIndex = Math.floor(Math.random() * poolOfPossiblePairs.length);\n    const pairCandidate = poolOfPossiblePairs[pairCandidateIndex];\n    const potentialPair = [userToPair.email, pairCandidate.email];\n    const serializedPairingEmails = serializeEmails(potentialPair);\n\n    return [pairCandidateIndex, potentialPair, serializedPairingEmails];\n  }\n\n  const userToPair = participants[0];\n  const poolOfPossiblePairs = participants.slice(1);\n\n  let [pairCandidateIndex, potentialPair, serializedPairingEmails] = findPotentialPair(poolOfPossiblePairs, userToPair);\n  let numTries = 0;\n\n  while (numTries++ < MAX_PAIRING_TRIES) {\n    if (!prevPairings.has(serializedPairingEmails)) break;\n\n    [pairCandidateIndex, potentialPair, serializedPairingEmails] = findPotentialPair(poolOfPossiblePairs, userToPair);\n  }\n\n  if (prevPairings.has(serializedPairingEmails)) {\n    logError(`Unable to find a novel pairing for ${serializedPairingEmails}`);\n  }\n\n  const rest = poolOfPossiblePairs.slice(0, pairCandidateIndex).concat(poolOfPossiblePairs.slice(pairCandidateIndex + 1));\n\n  return [potentialPair].concat(randomUniquePairing(prevPairings, rest));\n}\n\n/**\n * @description Joke generator\n * @returns {string} list of coffe jokes\n */\nfunction joke() {\n  return [\n    \"Barista: How do you take your coffee?\\n Me: Very, very seriously.\",\n    \"Q: Where do birds go for coffee?\\nA: To the NESTcafe\",\n    \"Q: What's the opposite of coffee?\\nA: Sneezy.\",\n    \"Q: What do you call it when you walk into a cafe you’re sure you’ve been to before?\\nA: Déjà brew\",\n    \"Q: Why should you be wary of 5-cent espresso?\\nA: It’s a cheap shot.\",\n    \"Q: Why did the espresso keep checking his watch?\\nA: Because he was pressed for time.\",\n    \"Drinking too much espresso can cause a latte problems.\",\n  ];\n}\n\n/**\n * @description Alternative to coffee generator\n * @returns {string[]} list of witty retorts\n */\nfunction wellThen() {\n  return [\n    \"Don't tell that to coffeebot :( Just keep it to yourself okay?\",\n    \"Don't let coffeebot tell you how to lead your life, you just follow your heart, okay?\",\n    \"Me either. Just drink some other liquid!\",\n    \"Don't worry, no one can tell what you're drinking over hangouts!\"\n  ];\n}\n\n/**\n * @description generates a string for current date\n * @returns {string} \"YYYY-MM-DD\"\n */\nfunction generatePairingDate() {\n  const today = new Date();\n\n  return `${today.getFullYear()}/${today.getMonth() + 1}/${today.getDate()}`;\n}\n\n/**\n * @description Tracks pairings by storing them in Sheet\n * @param {string[]} emails list of emails of participants that were paired\n */\nfunction recordPairing(emails) {\n  const recordSheet = getSpreadsheet(RECORD_SHEET_NAME);\n  const dateOfPairing = generatePairingDate();\n\n  recordSheet.appendRow([dateOfPairing, emails]);\n}\n\n/**\n * @description Generates email message to invite participants to join in coffeetime with a colleague\n * @param {string} allNames \n * @param {string} allTimezones \n * @param {string} allTopics \n * @returns {string} email message\n */\nfunction generateEmail(allNames, allTimezones, allTopics) {\n  return `\nHey ${allNames}!\n\nYou're invited to chat over coffee this week!  \n\nDon't like coffee? ${wellThen()[Math.floor(Math.random()*wellThen().length)]}\n\nWhen scheduling a time to chat, please mind everyone's timezones, which are: ${allTimezones}\n\nWhat should you talk about? Well that's up to you, but maybe you could talk about: ${allTopics}\n\nP.S.\n${joke()[Math.floor(Math.random()*joke().length)]}\n\nHappy chatting!\nCoffeebot ☕🤖\n`;\n}\n\n/**\n * @description Records the generated pairings for use in upcoming coffeetime\n * @param {string[][]} nextPairingEmails list of tuples of emails representing next group of participants to pair for coffee\n */\nfunction recordNextPairings(nextPairingEmails) {\n  const nextPairingSheet = getSpreadsheet(NEXT_PAIRINGS_SHEET_NAME);\n\n  nextPairingSheet.clearContents();\n\n  nextPairingEmails.forEach(emails => {\n    nextPairingSheet.appendRow([serializeEmails(emails)]);\n  });\n}\n\n/**\n * @description Fetch the pairings selected for next coffeetime\n * @returns {string[][]} List of tuples of emails addresses\n */\nfunction getNextPairingMatchupEmails() {\n  const sheet = getSpreadsheet(NEXT_PAIRINGS_SHEET_NAME);\n  const startRow = 1;\n  const lastRow = sheet.getLastRow();\n\n  return getSheetValues(sheet, startRow, lastRow, 1, 1).reduce((acc, row) => {\n    return acc.concat([deserializeEmails(row[0])]);\n  }, []); \n}\n\n/**\n * @description Perform pairing of participants, record pairings, and send out emails\n * @param {Object<string, string>[]} pairingData @see getPairingData\n * @param {string[]} matchups @see getPreviousPairings\n */\nfunction coffeePairingActivate(pairingData, matchups) {\n  const emailData = matchups.map(email => {\n    const index = pairingData.findIndex(participant => participant.email === email);\n    return pairingData[index];\n  }).reduce((acc, participant) => {\n    return {\n      names: acc.names.concat(participant.name),\n      emails: acc.emails.concat(participant.email),\n      timezones: acc.timezones.concat(participant.timezone),\n      topics: acc.topics.concat(participant.topics.split(/\\s*,\\s*/)),\n    };\n  }, { names: [], timezones: [], emails: [], topics: [] });\n    \n  const allTopics = uniqify(emailData.topics).join(', ');\n  const allNames = emailData.names.join(' & ');\n  const allTimezones = uniqify(emailData.timezones).join(', ');\n  const allEmails = serializeEmails(emailData.emails);\n  const subject = `Coffee Time with ${allNames}!`;\n  const message = generateEmail(allNames, allTimezones, allTopics);\n\n  recordPairing(allEmails);\n\n  MailApp.sendEmail(allEmails, subject, message, { name: 'Coffeebot' });\n}\n\n/**\n * @description Creates initial \"Signup\" sheet\n */\nfunction generateInitialSignupSheet() {\n  getSpreadsheet(PAIRING_SHEET_NAME, getSignupSheetColumns());\n}\n\n/**\n * @description Seeds the coffeetime pairings for upcoming coffeetime,\n *              storing them in the \"Next Pairings\" Sheet\n */\nfunction generateNextPairings() {\n    const pairingData = getPairingData();\n    const prevPairingEmails = getPreviousPairingEmails();\n    const nextPairings = randomUniquePairing(prevPairingEmails, pairingData);\n\n    recordNextPairings(nextPairings);\n}\n\n/**\n * @description Sends emails with data from the current spreadsheet.\n */\nfunction sendEmails() {\n  try {\n    const pairingData = getPairingData();\n    const nextPairingMatchupEmails = getNextPairingMatchupEmails();\n\n    nextPairingMatchupEmails.map(emails => coffeePairingActivate(pairingData, emails));\n  } catch (e) {\n    logError(e.message);\n  }\n}\n\nmodule.exports = {\n  deserializeEmails,\n  generateInitialSignupSheet,\n  generateNextPairings,\n  getToday,\n  mapRowDataToPairData,\n  randomUniquePairing,\n  sendEmails,\n  serializeEmails,\n  shouldSnooze,\n  uniqify,\n};\n"],"sourceRoot":""}